---FILE_MAP_START---
requirements.txt
run_backend.py
check_backend.py
app/__init__.py
app/core/__init__.py
app/core/config.py
app/core/db.py
app/core/security.py
app/models.py
app/schemas.py
app/deps.py
app/api/__init__.py
app/api/routes.py
app/main.py
---FILE_MAP_END---
---FILE_START requirements.txt---
fastapi
uvicorn[standard]
sqlmodel
pydantic-settings
python-jose[cryptography]
passlib[bcrypt]
python-multipart
psycopg2-binary
---FILE_END requirements.txt---
---FILE_START run_backend.py---
import uvicorn

if __name__ == "__main__":
    uvicorn.run("app.main:app", host="0.0.0.0", port=8000, reload=True)
---FILE_END run_backend.py---
---FILE_START check_backend.py---
import http.client
import sys

def check_server(host="localhost", port=8000):
    """Checks if the backend server is running."""
    try:
        conn = http.client.HTTPConnection(host, port, timeout=5)
        conn.request("GET", "/")
        response = conn.getresponse()
        if response.status == 200:
            print("Backend is running!")
            return True
        else:
            print(f"Backend returned status {response.status}")
            return False
    except ConnectionRefusedError:
        print("Connection refused. Is the backend running?")
        return False
    except Exception as e:
        print(f"An error occurred: {e}")
        return False
    finally:
        if 'conn' in locals():
            conn.close()

if __name__ == "__main__":
    if not check_server():
        sys.exit(1)
---FILE_END check_backend.py---
---FILE_START app/__init__.py---
# This file can be empty.
---FILE_END app/__init__.py---
---FILE_START app/core/__init__.py---
# This file can be empty.
---FILE_END app/core/__init__.py---
---FILE_START app/core/config.py---
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    DB_URL: str = "sqlite:///./test.db"
    SECRET_KEY: str = "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30

    class Config:
        env_file = ".env"

settings = Settings()
---FILE_END app/core/config.py---
---FILE_START app/core/db.py---
from sqlmodel import create_engine, Session, SQLModel
from app.core.config import settings

# The connect_args is needed only for SQLite
connect_args = {"check_same_thread": False} if "sqlite" in settings.DB_URL else {}
engine = create_engine(settings.DB_URL, echo=True, connect_args=connect_args)

def create_db_and_tables():
    # Import all models here before calling create_all
    # so that they are registered with SQLModel's metadata
    from app import models 
    SQLModel.metadata.create_all(engine)

def get_session():
    with Session(engine) as session:
        yield session
---FILE_END app/core/db.py---
---FILE_START app/core/security.py---
from datetime import datetime, timedelta, timezone
from typing import Any, Union
from jose import jwt
from passlib.context import CryptContext
from app.core.config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

ALGORITHM = settings.ALGORITHM
SECRET_KEY = settings.SECRET_KEY
ACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES

def create_access_token(subject: Union[str, Any], expires_delta: timedelta = None) -> str:
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode = {"exp": expire, "sub": str(subject)}
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)
---FILE_END app/core/security.py---
---FILE_START app/models.py---
import enum
from typing import List, Optional
from datetime import date
from sqlmodel import Field, Relationship, SQLModel

class UserRole(str, enum.Enum):
    employee = "employee"
    manager = "manager"
    admin = "admin"

class User(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    email: str = Field(unique=True, index=True)
    hashed_password: str
    first_name: str
    last_name: str
    is_active: bool = Field(default=True)
    role: UserRole = Field(default=UserRole.employee)
    
    manager_id: Optional[int] = Field(default=None, foreign_key="user.id")

    manager: Optional["User"] = Relationship(
        back_populates="team_members",
        sa_relationship_kwargs=dict(remote_side="User.id")
    )
    team_members: List["User"] = Relationship(back_populates="manager")
    time_entries: List["TimeEntry"] = Relationship(back_populates="user")

class Project(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str = Field(index=True)
    is_active: bool = Field(default=True)

    time_entries: List["TimeEntry"] = Relationship(back_populates="project")

class TimeEntry(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    date: date
    hours_worked: float
    description: Optional[str] = Field(default=None)
    
    user_id: int = Field(foreign_key="user.id")
    project_id: int = Field(foreign_key="project.id")

    user: User = Relationship(back_populates="time_entries")
    project: Project = Relationship(back_populates="time_entries")
---FILE_END app/models.py---
---FILE_START app/schemas.py---
from pydantic import BaseModel, EmailStr
from typing import List, Optional
from datetime import date
from app.models import UserRole

# Token
class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    email: Optional[str] = None

# User
class UserBase(BaseModel):
    email: EmailStr
    first_name: str
    last_name: str
    role: UserRole

class UserCreate(UserBase):
    password: str

class UserRead(UserBase):
    id: int
    is_active: bool
    manager_id: Optional[int] = None

    class Config:
        from_attributes = True

class UserUpdate(BaseModel):
    email: Optional[EmailStr] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    password: Optional[str] = None
    is_active: Optional[bool] = None
    role: Optional[UserRole] = None
    manager_id: Optional[int] = None

# Project
class ProjectBase(BaseModel):
    name: str
    is_active: bool = True

class ProjectCreate(ProjectBase):
    pass

class ProjectRead(ProjectBase):
    id: int

    class Config:
        from_attributes = True

class ProjectUpdate(BaseModel):
    name: Optional[str] = None
    is_active: Optional[bool] = None

# TimeEntry
class TimeEntryBase(BaseModel):
    date: date
    hours_worked: float
    description: Optional[str] = None
    project_id: int

class TimeEntryCreate(TimeEntryBase):
    pass

class TimeEntryRead(TimeEntryBase):
    id: int
    user_id: int

    class Config:
        from_attributes = True

class TimeEntryUpdate(BaseModel):
    date: Optional[date] = None
    hours_worked: Optional[float] = None
    description: Optional[str] = None
    project_id: Optional[int] = None
---FILE_END app/schemas.py---
---FILE_START app/deps.py---
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlmodel import Session, select
from app.core.config import settings
from app.core.db import get_session
from app.models import User

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/token")

def get_current_user(
    session: Session = Depends(get_session), token: str = Depends(oauth2_scheme)
) -> User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(
            token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM]
        )
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    
    user = session.exec(select(User).where(User.email == email)).first()
    if user is None:
        raise credentials_exception
    return user
---FILE_END app/deps.py---
---FILE_START app/api/__init__.py---
# This file can be empty.
---FILE_END app/api/__init__.py---
---FILE_START app/api/routes.py---
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlmodel import Session, select
from typing import Any

from app.core import security
from app.core.db import get_session
from app.models import User
from app import schemas
from app import deps

router = APIRouter()

@router.post("/token", response_model=schemas.Token)
def login_for_access_token(
    session: Session = Depends(get_session),
    form_data: OAuth2PasswordRequestForm = Depends()
) -> Any:
    """
    OAuth2 compatible token login, get an access token for future requests.
    """
    user = session.exec(select(User).where(User.email == form_data.username)).first()
    if not user or not security.verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    if not user.is_active:
        raise HTTPException(status_code=400, detail="Inactive user")
        
    access_token = security.create_access_token(subject=user.email)
    return {"access_token": access_token, "token_type": "bearer"}

@router.get("/users/me", response_model=schemas.UserRead)
def read_users_me(current_user: User = Depends(deps.get_current_user)):
    """
    Get current user.
    """
    return current_user
---FILE_END app/api/routes.py---
---FILE_START app/main.py---
from fastapi import FastAPI
from sqlmodel import Session, select

from app.api import routes as api_routes
from app.core.db import create_db_and_tables, engine
from app.core.security import get_password_hash
from app.models import User, UserRole

app = FastAPI(title="Employee Time Tracking System")

@app.on_event("startup")
def on_startup():
    create_db_and_tables()
    
    with Session(engine) as session:
        # Check if admin user exists
        statement = select(User).where(User.email == "admin@example.com")
        admin_user = session.exec(statement).first()
        
        if not admin_user:
            # Create admin user
            hashed_password = get_password_hash("adminpassword")
            admin_user = User(
                email="admin@example.com",
                hashed_password=hashed_password,
                first_name="Admin",
                last_name="User",
                role=UserRole.admin,
                is_active=True
            )
            session.add(admin_user)
            session.commit()
            print("Default admin user created with email: admin@example.com and password: adminpassword")


app.include_router(api_routes.router, prefix="/api", tags=["api"])

@app.get("/")
def read_root():
    return {"message": "Welcome to the Employee Time Tracking System API"}
---FILE_END app/main.py---